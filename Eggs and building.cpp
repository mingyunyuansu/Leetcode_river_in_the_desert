//十分有意思的一个题目，说假设我们有2个鸡蛋，100层楼，设计一个方案找出会把鸡蛋摔碎的最低楼层。
//据说是从前谷歌的面试题，但是去年的阿里面经也问了。。。
//首先这个问题都不是那么好理解。因为鸡蛋在多高会碎是完全不知道的，而我们却要对完全不知道的情况找到一个最小值，这个很反直觉。
//我花了好半天才适应这种思考方式，大概就是，“找出最坏情况下的最小尝试次数”。
//比如2分法，我们先从50楼扔，碎了，那么第二颗蛋就得从1楼一直往上试。假如直到49层才碎，那么这就说明这个方法的最坏情况就是1 + 49。
//（没碎也类似，没碎的话我们从75层再试，还没碎，再从（75+100）/2开始试，试到100碎了，第二颗蛋又要从一层开始。
//要是其实真正会碎的楼层是99层，我们的试验次数就是100+了。。。
//这就叫最坏情况，要记住最坏情况是后定义的，我们先有了方案再来讨论最多会到多少次，这就是反直觉的点。

//但换一种思维，从结果来推条件。假设最小次数就是x，那么我们只能从x层开始试。因为如果在x层第一颗蛋就碎了，我们第二颗蛋必须试验1 ~ x - 1的所有楼。
//最坏情况是临界楼层是x - 1楼，总试验次数x次，这才满足x次实验这个先决条件。
//假设从x楼扔没碎我们就得把第一颗蛋拿到高处再试。这个也是被规定好的，最高只能往上走x - 1搂。
//这也是难理解的一个点，举个例子好理解一点。假设我们的x是14，那么我们第一次在14楼试了一次，没碎，这时应该在14 + 13 = 27楼试。只有这样，要是在27楼碎了，且临界楼层是26楼（最坏情况），我们从15 层 试到26楼（12次），才满足1 + 1 + 12 = 14。要是从更高层开始试，碎了，总试验次数就超过14了。
//记住是结果决定条件（即临界楼层是哪层）。
//照这样的思路，我们有最坏情况， x + x - 1 + x - 2 + ... + 2 + 1 >= 100，愣是往上试到了100层，第一颗蛋才碎（或者没碎，但是最坏情况需要第一颗蛋碎）。
//x * (x + 1) / 2 >= 100 解得 x = 14。

//而用编程的办法可以拓展到n个蛋k层楼。
//递归的代码很直观，就是枚举每一次从i层扔，所需次数的最大值（因为是最坏情况）中的最小值（保证最优）。
//但是递归的时间复杂度是指数级的，重复计算太多了，100层根本出不来结果。。。
//于是转为DP
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int recur(int n, int k) {
    if (k <= 1) return k;
    if (n == 1) return k;
    int ans = INT_MAX;
    for (int i = 1; i <= k; ++i) {
        ans = min(1 + max(recur(n - 1,  i - 1), recur(n, k - i)), ans);
    }
    return ans;
}

//这个DP就是递归的思维实现，也是对于给定楼层j，枚举1楼到这j楼的所有情况中的最优解。
//max取的是碎和不碎的最大值，min取的是整体的最小值。
//dp时间复杂度n*（1 + 2 + ...+ k-1 + k)，化为O(n*k^2)。
int dyp(int n, int k) {
    vector<vector<int>> dp(n + 1, vector<int>(k+1, INT_MAX));
    dp[0][0] = 0;
    for (int i = 1; i <= k; ++i) {
        dp[1][i] = i;
    }
    for (int j = 1; j <= n; ++j) {
        dp[j][1] = 1;
        dp[j][0] = 0;
    }
    for (int i = 2; i <= n; ++i) {
        for (int j = 2; j <= k; ++j) {
            for (int l = 1; l <= j; ++l)
                dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][l - 1], dp[i][j - l]));
        }
    }
    return dp[n][k];
}
int main() {
    int n = 2, k = 2000;
    //cout << recur(n, k) << endl;
    cout << dyp(n, k) << endl;
    return 0;
}